#!/usr/bin/env ruby

require 'io/console'

def help
  puts 'Usage: bumpdep updated-gem-name new.version [noconfirm]'
  puts 'Example: bumpdep timecop 0.22.100'
  exit 1
end

def update_repo!(gem, version)
  message = "Updated version of #{gem} to #{version}"
  system('git', 'commit', '-am', message) || fail('Failed to commit change')
  system('git', 'push', 'origin', 'master') || fail('Failed to push change')
rescue
  puts "Failed to update #{gem}"
end

def update_bundle!
  return unless system('git cat-file -e HEAD:Gemfile.lock &>/dev/null')
  system('bundle update')
end

def replace_version!(file, contents, gem, version)
  puts "Updating #{Dir.pwd}"
  contents.map! do |x|
    x.sub(/(?= '#{gem}', '~> )[\w.]+(?=')$/, version)
  end
  File.open(file, 'w') { |fh| fh.write(contents.join) }
  true
end

def confirm?(gem, old_version, file)
  print "Want to update #{gem}'s #{file} from #{old_version}? [Y/n] "
  gets.chomp.downcase != 'n'
end

def update_file!(file, gem, version, noconfirm)
  contents = File.readlines(file)
  res = contents.find { |x| x.match(/ '#{gem}', '~> ([\w.]+)'$/) }
  return if res[1] == version
  ok = confirm?(gem, res[1], file) unless noconfirm
  replace_version!(file, contents, gem, version) if ok
end

def repo_clean?
  res = `git status 2>&1`.match(/working directory clean/)
  puts "Git repo not clean: #{Dir.pwd}" unless res
  return res
end

def update_repo!(repo, gem, version, noconfirm)
  Dir.chdir(repo) do
    next unless repo_clean?
    a = update_file! 'Gemfile', gem, version, noconfirm
    b = update_file! Dir.glob('*.gemspec').first, gem, version, noconfirm
    next unless a || b
    update_bundle!
    update_repo! gem, version
  end
end

def all_repos(pattern)
  Dir.glob("**/#{pattern}").map { |x| File.dirname(x) }.select do |x|
    Dir.exist? File.join(x, '.git')
  end
end

gem = ARGV.shift || help
version = ARGV.shift || help
noconfirm = ARGV.shift || nil
help unless gem.match(/^\S+$/) && version.match(/^[\w.]+$/)

all_repos.each { |x| update_repo! x, gem, version, noconfirm }
